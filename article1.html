<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Quick Start - Layui</title>
    <link href="./layui/css/layui.css" rel="stylesheet">
    <link href="./asserts/css/prism.css" rel="stylesheet">
    <style>
        .your-element-class {
            background-image: url(asserts/img/gd.png);
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: fixed;
        }

        .heading-anchor {
            text-align: left;
            font-size: 50px;
            font-weight: bolder;
        }

        p {
            margin: 5px 5px;
        }

        pre {
            background-color: #333;
            color: #fff;
            padding: 10px;
            border-radius: 4px;
        }

        body {
            padding: 20px;
            text-align: center;
            font-size: 24px;
            color: #333;
        }
    </style>
</head>

<div class="your-element-class">
    <!-- HTML Content -->
    <div class="layui-header header top">
        <ul class="layui-nav">
            <li class="layui-nav-item"><img class="logo-img mob-show" src="./asserts/img/logo.jpg"></li>
            <li class="layui-nav-item"><a href="./index.html"><i class="layui-icon layui-icon-home"></i> 首
                    页</a></li>
            <li class="layui-nav-item  layui-this"><a href="./article.html"><i class="layui-icon layui-icon-slider"></i>
                    文 章</a></a>
            </li>
            <li class="layui-nav-item"><a href="./about.html"><i class="layui-icon layui-icon-username"></i> 关 于</a>
            </li>
        </ul>
    </div>
    <div class="layui-container layui-row page-main">
        <div class="layui-col-md1"></div>
        <!-- 左侧边栏 开始 -->
        <div class="layui-col-md3 rd mob-show ">
            <div class="layui-panel site-menu rd">
                <div class="layui-card rd">
                    <div class="layui-card-header">
                        <i class="layui-icon layui-icon-theme"></i> 作者信息
                    </div>
                    <div class="layui-card-body">
                        <div class="layui-row">
                            <div class="layui-col-md5">
                                <img class="avatar" src="./asserts/img/logo.jpg" />
                            </div>
                            <div class="layui-col-md7">
                                <h4><i class="layui-icon layui-icon-friends"></i> Nick:mbrc</h4>
                                <hr>
                                <h4><i class="layui-icon layui-icon-login-qq"></i> QQ: 2832122084</h4>
                            </div>
                        </div>
                        <div class="layui-row">
                            <blockquote class="layui-elem-quote quote-margin">
                                功成不必在我，功成必定有我
                            </blockquote>
                        </div>
                    </div>
                </div>
            </div>
            <br>
            <div class="layui-panel rd">
                <div class="layui-card rd">
                    <div class="layui-card-header">
                        <i class="layui-icon layui-icon-form"></i> 最近文章
                    </div>
                    <div class="layui-card-body">
                        <div class="layui-row">
                            <ul class="layui-menu">
                                <li class="layui-menu-item"><a href="./article5.html">我自己写的代码(原创)</a></li>
                                <li class="layui-menu-item"><a href="./article1.html">欢迎回到 C++ - 现代 C++(转) -
                                        [2023/05/25]</a>
                                </li>
                                <li class="layui-menu-item"><a href="./article2.html">Python For Beginners(转) -
                                        [2023/05/25]</a></li>
                                <li class="layui-menu-item"><a href="./article3.html">CSS 入门概述(转) - [2023/05/25]</a>
                                </li>
                                <li class="layui-menu-item"><a href="./article4.html">JavaScript——用户端动态脚本(转) -
                                        [2023/05/25]</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="layui-panel rd">
                <div class="layui-card rd">
                    <div class="layui-card-header">
                        <i class="layui-icon layui-icon-note"></i> 文章标签
                    </div>
                    <div class="layui-card-body">
                        <span class="layui-badge layui-bg-orange">c++</span>&nbsp;
                        <span class="layui-badge">html</span>&nbsp;
                        <span class="layui-badge layui-bg-green">css</span>&nbsp;
                        <span class="layui-badge layui-bg-blue">javascript</span>&nbsp;
                        <span class="layui-badge layui-bg-green">python</span>&nbsp;
                        <span class="layui-badge">java</span>
                    </div>
                </div>
            </div>
            <div style="position: sticky; top: 120px;z-index: 9000;">
                <div class="layui-panel site-menu rd">
                    <div class="layui-card rd mob-show">
                        <div class="layui-card-header">
                            <i class="layui-icon layui-icon-note"></i> 本文目录
                        </div>
                        <div class="layui-card-body">
                            <div class="layui-row">
                                <ul class="layui-menu">
                                    <!---->
                                    <li>
                                        <a href="#resources-and-smart-pointers"><!---->资源和智能指针<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#stdstring-and-stdstring_view"><!---->std::string 和
                                            std::string_view<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#stdvector-and-other-standard-library-containers"><!---->std::vector
                                            和其他标准库容器<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#standard-library-algorithms"><!---->标准库算法<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#auto-instead-of-explicit-type-names"><!---->用 auto 替代显式类型名称<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#range-based-for-loops"><!---->基于范围的 for 循环<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#constexpr-expressions-instead-of-macros"><!---->用 constexpr
                                            表达式替代宏<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#uniform-initialization"><!---->统一初始化<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#move-semantics"><!---->移动语义<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#lambda-expressions"><!---->Lambda 表达式<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#exceptions"><!---->异常<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#stdatomic"><!---->std::atomic<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#stdvariant-c17"><!---->std::variant (C++17)<!----></a>
                                    </li>
                                    <!---->
                                    <li>
                                        <a href="#see-also"><!---->请参阅<!----></a>
                                    </li>
                                    <!---->
                                </ul>
                                <!---->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="layui-col-md1">&nbsp;</div>
        <div class="layui-col-md8 site-content">

            <div class="content" style="font-family: 'Courier New', Courier, monospace; font-weight: bold;">
                <br><br><br><br><br>
                <h1 style="text-align: center;">欢迎回到 C++ - 现代 C++</h1><br>
                <p style="text-align:center; font: size 50px;">项目·文章评审日期:2023/04/03</p>

                <!-- <content> -->
                <br>
                <p>自创建以来，C++ 即已成为世界上最常用的编程语言之一。 正确编写的 C++ 程序快速、高效。 相对于其他语言，该语言更加灵活：它可以在最高的抽象级别上运行，还可以在硅级低级别上运行。 C++
                    提供高度优化的标准库。
                    它支持访问低级别硬件功能，从而最大限度地提高速度并最大程度地降低内存需求。 C++ 几乎可以创建任何类型的程序：游戏、设备驱动程序、HPC、云、桌面、嵌入式和移动应用等。
                    甚至用于其他编程语言的库和编译器也使用
                    C++
                    编写。</p><br>
                <p>C++ 的原始要求之一是与 C 语言向后兼容。 因此，C++ 始终允许 C 样式编程，其中包含原始指针、数组、以 null 结尾的字符串和其他功能。 它们可以实现良好的性能，但也可能会引发 bug
                    并增加复杂性。
                    C++
                    的演变注重可显著降低 C 样式惯例使用需求的功能。 如果需要，你仍可以使用旧的 C 编程设施。 但是，在新式 C++ 代码中，对上述设施的需求会越来越少。 现代 C++
                    代码更加简单、安全、美观，而且速度仍像以往一样快速。
                </p>
                <p>下面几个部分概述了现代 C++ 的主要功能。 此处列出的功能在 C++11 及更高版本中可用，除非另有说明。 在 Microsoft C++ 编译器中，可以设置 <a
                        href="https://learn.microsoft.com/zh-cn/cpp/build/reference/std-specify-language-standard-version?view=msvc-170"
                        data-linktype="relative-path"><code>/std</code></a> 编译器选项，指定要用于项目的标准版本。</p>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#resources-and-smart-pointers" aria-label="节标题：资源和智能指针"></a>
                    <h2 id="resources-and-smart-pointers" class="heading-anchor">资源和智能指针</h2>
                </div>
                <p>C 样式编程的一个主要 bug 类型是内存泄漏。 泄漏通常是由未能为使用 <strong><code>new</code></strong> 分配的内存调用
                    <strong><code>delete</code></strong> 导致的。 现代 C++ 强调“资源获取即初始化”(RAII) 原则。 其理念很简单。
                    资源（堆内存、文件句柄、套接字等）应由对象“拥有”。
                    该对象在其构造函数中创建或接收新分配的资源，并在其析构函数中将此资源删除。 RAII 原则可确保当所属对象超出范围时，所有资源都能正确返回到操作系统。
                </p>
                <p>为了支持对 RAII 原则的简单采用，C++ 标准库提供了三种智能指针类型：<a
                        href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unique-ptr-class?view=msvc-170"
                        data-linktype="relative-path"><code>std::unique_ptr</code></a>、<a
                        href="https://learn.microsoft.com/zh-cn/cpp/standard-library/shared-ptr-class?view=msvc-170"
                        data-linktype="relative-path"><code>std::shared_ptr</code></a> 和 <a
                        href="https://learn.microsoft.com/zh-cn/cpp/standard-library/weak-ptr-class?view=msvc-170"
                        data-linktype="relative-path"><code>std::weak_ptr</code></a>。 智能指针可处理对其拥有的内存的分配和删除。
                    下面的示例演示了一个类，其中包含一个数组成员，该成员是在调用 <code>make_unique()</code> 时在堆上分配的。 对
                    <strong><code>new</code></strong> 和
                    <strong><code>delete</code></strong> 的调用将由 <code>unique_ptr</code> 类封装。 当 <code>widget</code>
                    对象超出范围时，将调用
                    unique_ptr 析构函数，此函数将释放为数组分配的内存。
                </p>
                <div class="codeHeader" id="code-try-0" data-bi-name="code-header"><span class="language">C++</span>
                    <button type="button" class="action position-relative display-none-print" data-bi-name="copy">
                        <span class="icon margin-right-xxs" aria-hidden="true">
                            <span class="docon docon-edit-copy"></span>
                        </span>
                        <span>复制</span>
                        <div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent"
                            aria-hidden="true">
                            <span class="icon font-size-lg">
                                <span class="docon docon-check-mark"></span>
                            </span>
                        </div>
                    </button>
                </div>
                <pre class="has-inner-focus"><code class="lang-cpp" data-author-content="#include <memory>
                class widget
                {
                private:
                    std::unique_ptr<int[]> data;
                public:
                    widget(const int size) { data = std::make_unique<int[]>(size); }
                    void do_something() {}
                };
                
                void functionUsingWidget() {
                    widget w(1000000);  // lifetime automatically tied to enclosing scope
                                        // constructs w, including the w.data gadget member
                    // ...
                    w.do_something();
                    // ...
                } // automatic destruction and deallocation for w and w.data
                "><span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
                <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">widget</span>
                {</span>
                <span class="hljs-keyword">private</span>:
                    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>[]&gt; data;
                <span class="hljs-keyword">public</span>:
                    widget(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> size) { data = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-keyword">int</span>[]&gt;(size); }
                    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">()</span> </span>{}
                };
                
                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">functionUsingWidget</span><span class="hljs-params">()</span> </span>{
                    <span class="hljs-function">widget <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1000000</span>)</span></span>;  <span class="hljs-comment">// lifetime automatically tied to enclosing scope</span>
                                        <span class="hljs-comment">// constructs w, including the w.data gadget member</span>
                    <span class="hljs-comment">// ...</span>
                    w.do_something();
                    <span class="hljs-comment">// ...</span>
                } <span class="hljs-comment">// automatic destruction and deallocation for w and w.data</span>
                </span></code></pre>
                <p>请尽可能地使用智能指针管理堆内存。 如果必须显式使用 <strong><code>new</code></strong> 和 <strong><code>delete</code></strong>
                    运算符，请遵循
                    RAII
                    原则。 有关详细信息，请参阅<a
                        href="https://learn.microsoft.com/zh-cn/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170"
                        data-linktype="relative-path">对象生存期和资源管理 (RAII)</a>。</p>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#stdstring-and-stdstring_view" aria-label="节标题：std::string 和 std::string_view"></a>
                    <h2 id="stdstring-and-stdstring_view" class="heading-anchor"><code>std::string</code> 和
                        <code>std::string_view</code>
                    </h2>
                </div>
                <p>C 样式字符串是 bug 的另一个主要来源。 通过使用 <a
                        href="https://learn.microsoft.com/zh-cn/cpp/standard-library/basic-string-class?view=msvc-170"
                        data-linktype="relative-path"><code>std::string</code> 和 <code>std::wstring</code></a>，几乎可以消除与 C
                    样式字符串关联的所有错误。 还可以利用成员函数的优势进行搜索、追加和在前面追加等操作。 两者都对速度进行了高度优化。 将字符串传递到仅需要只读访问权限的函数时，在 C++17 中，可以使用 <a
                        href="https://learn.microsoft.com/zh-cn/cpp/standard-library/basic-string-view-class?view=msvc-170"
                        data-linktype="relative-path"><code>std::string_view</code></a>，以便提高性能。</p>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#stdvector-and-other-standard-library-containers"
                        aria-label="节标题：std::vector 和其他标准库容器"></a>
                    <h2 id="stdvector-and-other-standard-library-containers" class="heading-anchor">
                        <code>std::vector</code>
                        和其他标准库容器
                    </h2>
                </div>
                <p>标准库容器都遵循 RAII 原则。 它们为安全遍历元素提供迭代器。 此外，它们对性能进行了高度优化，并且已充分测试正确性。 通过使用这些容器，可以消除自定义数据结构中可能引入的 bug 或低效问题。
                    使用 <a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-170"
                        data-linktype="relative-path"><code>vector</code></a> 替代原始数组，来作为 C++ 中的序列容器。</p>
                <div class="codeHeader" id="code-try-1" data-bi-name="code-header"><span class="language">C++</span>
                    <button type="button" class="action position-relative display-none-print" data-bi-name="copy">
                        <span class="icon margin-right-xxs" aria-hidden="true">
                            <span class="docon docon-edit-copy"></span>
                        </span>
                        <span>复制</span>
                        <div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent"
                            aria-hidden="true">
                            <span class="icon font-size-lg">
                                <span class="docon docon-check-mark"></span>
                            </span>
                        </div>
                    </button>
                </div>
                <pre class="has-inner-focus"><code class="lang-cpp" data-author-content="vector<string> apples;
                    apples.push_back(&quot;Granny Smith&quot;);
                    "><span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; apples;
                    apples.push_back(<span class="hljs-string">"Granny Smith"</span>);
                    </span></code></pre>
                <p>使用 <a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/map-class?view=msvc-170"
                        data-linktype="relative-path"><code>map</code></a>（而不是 <code>unordered_map</code>），作为默认关联容器。
                    对于退化和多案例，使用
                    <a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/set-class?view=msvc-170"
                        data-linktype="relative-path"><code>set</code></a>、<a
                        href="https://learn.microsoft.com/zh-cn/cpp/standard-library/multimap-class?view=msvc-170"
                        data-linktype="relative-path"><code>multimap</code></a> 和 <a
                        href="https://learn.microsoft.com/zh-cn/cpp/standard-library/multiset-class?view=msvc-170"
                        data-linktype="relative-path"><code>multiset</code></a>。
                </p>
                <div class="codeHeader" id="code-try-2" data-bi-name="code-header"><span class="language">C++</span>
                    <button type="button" class="action position-relative display-none-print" data-bi-name="copy">
                        <span class="icon margin-right-xxs" aria-hidden="true">
                            <span class="docon docon-edit-copy"></span>
                        </span>
                        <span>复制</span>
                        <div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent"
                            aria-hidden="true">
                            <span class="icon font-size-lg">
                                <span class="docon docon-check-mark"></span>
                            </span>
                        </div>
                    </button>
                </div>
                <pre class="has-inner-focus"><code class="lang-cpp" data-author-content="map<string, string> apple_color;
                    // ...
                    apple_color[&quot;Granny Smith&quot;] = &quot;Green&quot;;
                    "><span><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; apple_color;
                    <span class="hljs-comment">// ...</span>
                    apple_color[<span class="hljs-string">"Granny Smith"</span>] = <span class="hljs-string">"Green"</span>;
                    </span></code></pre>
                <p>需要进行性能优化时，请考虑以下用法：</p>
                <ul>
                    <li>
                        <p>例如，当嵌入非常重要时，将 <a
                                href="https://learn.microsoft.com/zh-cn/cpp/standard-library/array-class-stl?view=msvc-170"
                                data-linktype="relative-path"><code>array</code></a> 类型作为类成员。</p>
                    </li>
                    <li>
                        <p>使用无序的关联容器，例如 <a
                                href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170"
                                data-linktype="relative-path"><code>unordered_map</code></a>。
                            它们的每个元素的开销较低，并且具有固定时间查找功能，但正确高效地使用它们的难度更高。</p>
                    </li>
                    <li>
                        <p>使用排序的 <code>vector</code>。 有关详细信息，请参阅<a
                                href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithms?view=msvc-170"
                                data-linktype="relative-path">算法</a>。</p>
                    </li>
                </ul>
                <p>不要使用 C 样式数组。 对于需要直接访问数据的旧 API，请改用 <code>f(vec.data(), vec.size());</code> 等访问器方法。 有关容器的详细信息，请参阅 <a
                        href="https://learn.microsoft.com/zh-cn/cpp/standard-library/stl-containers?view=msvc-170"
                        data-linktype="relative-path">C++ 标准库容器</a>。</p>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#standard-library-algorithms" aria-label="节标题：标准库算法"></a>
                    <h2 id="standard-library-algorithms" class="heading-anchor">标准库算法</h2>
                </div>
                <p>在假设需要为程序编写自定义算法之前，请先查看 C++ 标准库<a
                        href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm?view=msvc-170"
                        data-linktype="relative-path">算法</a>。 标准库包含许多常见操作（如搜索、排序、筛选和随机化）的算法分类，这些分类在不断增长。 数学库的内容很广泛。 在
                    C++17
                    及更高版本中，提供了许多算法的并行版本。</p>
                <p>以下是一些重要示例：</p>
                <ul>
                    <li>
                        <p><code>for_each</code>，默认遍历算法（以及基于范围的 <code>for</code> 循环）。</p>
                    </li>
                    <li>
                        <p><code>transform</code>，用于对容器元素进行非就地修改</p>
                    </li>
                    <li>
                        <p><code>find_if</code>，默认搜索算法。</p>
                    </li>
                    <li>
                        <p><code>sort</code>、<code>lower_bound</code> 和其他默认的排序和搜索算法。</p>
                    </li>
                </ul>
                <p>若要编写比较运算符，请使用严格的 <strong><code>&lt;</code></strong>，并尽可能使用命名 lambda。</p>
                <div class="codeHeader" id="code-try-3" data-bi-name="code-header"><span class="language">C++</span>
                    <button type="button" class="action position-relative display-none-print" data-bi-name="copy">
                        <span class="icon margin-right-xxs" aria-hidden="true">
                            <span class="docon docon-edit-copy"></span>
                        </span>
                        <span>复制</span>
                        <div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent"
                            aria-hidden="true">
                            <span class="icon font-size-lg">
                                <span class="docon docon-check-mark"></span>
                            </span>
                        </div>
                    </button>
                </div>
                <pre class="has-inner-focus"><code class="lang-cpp" data-author-content="auto comp = [](const widget&amp; w1, const widget&amp; w2)
                         { return w1.weight() < w2.weight(); }
                    
                    sort( v.begin(), v.end(), comp );
                    
                    auto i = lower_bound( v.begin(), v.end(), widget{0}, comp );
                    "><span><span class="hljs-keyword">auto</span> comp = [](<span class="hljs-keyword">const</span> widget&amp; w1, <span class="hljs-keyword">const</span> widget&amp; w2)
                         { <span class="hljs-keyword">return</span> w1.weight() &lt; w2.weight(); }
                    
                    sort( v.begin(), v.end(), comp );
                    
                    <span class="hljs-keyword">auto</span> i = lower_bound( v.begin(), v.end(), widget{<span class="hljs-number">0</span>}, comp );
                    </span></code></pre>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#auto-instead-of-explicit-type-names" aria-label="节标题：用 auto 替代显式类型名称"></a>
                    <h2 id="auto-instead-of-explicit-type-names" class="heading-anchor">用 <code>auto</code> 替代显式类型名称
                    </h2>
                </div>
                <p>C++11 引入了 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/auto-cpp?view=msvc-170"
                        data-linktype="relative-path"><code>auto</code></a> 关键字，以便可将其用于变量、函数和模板声明中。
                    <strong><code>auto</code></strong> 会指示编译器推导对象的类型，这样你就无需显式键入类型。
                    当推导出的类型是嵌套模板时，<strong><code>auto</code></strong>
                    尤其有用：
                </p>
                <div class="codeHeader" id="code-try-4" data-bi-name="code-header"><span class="language">C++</span>
                    <button type="button" class="action position-relative display-none-print" data-bi-name="copy">
                        <span class="icon margin-right-xxs" aria-hidden="true">
                            <span class="docon docon-edit-copy"></span>
                        </span>
                        <span>复制</span>
                        <div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent"
                            aria-hidden="true">
                            <span class="icon font-size-lg">
                                <span class="docon docon-check-mark"></span>
                            </span>
                        </div>
                    </button>
                </div>
                <pre class="has-inner-focus"><code class="lang-cpp" data-author-content="map<int,list<string>>::iterator i = m.begin(); // C-style
                    auto i = m.begin(); // modern C++
                    "><span><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;::iterator i = m.begin(); <span class="hljs-comment">// C-style</span>
                    <span class="hljs-keyword">auto</span> i = m.begin(); <span class="hljs-comment">// modern C++</span>
                    </span></code></pre>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#range-based-for-loops" aria-label="节标题：基于范围的 for 循环"></a>
                    <h2 id="range-based-for-loops" class="heading-anchor">基于范围的 <code>for</code> 循环</h2>
                </div>
                <p>对数组和容器的 C 样式迭代容易引发索引错误，而且键入过程单调乏味。 若要消除这些错误，并提高代码的可读性，可使用基于范围的 <strong><code>for</code></strong>
                    循环，此循环包含标准库容器和原始数组。 有关详细信息，请参阅<a
                        href="https://learn.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170"
                        data-linktype="relative-path">基于范围的 <code>for</code> 语句</a>。</p>
                <div class="codeHeader" id="code-try-5" data-bi-name="code-header"><span class="language">C++</span>
                    <button type="button" class="action position-relative display-none-print" data-bi-name="copy">
                        <span class="icon margin-right-xxs" aria-hidden="true">
                            <span class="docon docon-edit-copy"></span>
                        </span>
                        <span>复制</span>
                        <div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent"
                            aria-hidden="true">
                            <span class="icon font-size-lg">
                                <span class="docon docon-check-mark"></span>
                            </span>
                        </div>
                    </button>
                </div>
                <pre class="has-inner-focus"><code class="lang-cpp" data-author-content="#include <iostream>
                    #include <vector>
                    
                    int main()
                    {
                        std::vector<int> v {1,2,3};
                    
                        // C-style
                        for(int i = 0; i < v.size(); ++i)
                        {
                            std::cout << v[i];
                        }
                    
                        // Modern C++:
                        for(auto&amp; num : v)
                        {
                            std::cout << num;
                        }
                    }
                    "><span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
                    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
                    
                    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
                    </span>{
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
                    
                        <span class="hljs-comment">// C-style</span>
                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v.size(); ++i)
                        {
                            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; v[i];
                        }
                    
                        <span class="hljs-comment">// Modern C++:</span>
                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num : v)
                        {
                            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; num;
                        }
                    }
                    </span></code></pre>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#constexpr-expressions-instead-of-macros" aria-label="节标题：用 constexpr 表达式替代宏"></a>
                    <h2 id="constexpr-expressions-instead-of-macros" class="heading-anchor">用 <code>constexpr</code>
                        表达式替代宏</h2>
                </div>
                <p>C 和 C++ 中的宏是指编译之前由预处理器处理的标记。 在编译文件之前，宏标记的每个实例都将替换为其定义的值或表达式。 C 样式编程通常使用宏来定义编译时常量值。 但宏容易出错且难以调试。 在现代
                    C++
                    中，应优先使用
                    <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/constexpr-cpp?view=msvc-170"
                        data-linktype="relative-path"><code>constexpr</code></a> 变量定义编译时常量：
                </p>
                <div class="codeHeader" id="code-try-6" data-bi-name="code-header"><span class="language">C++</span>
                    <button type="button" class="action position-relative display-none-print" data-bi-name="copy">
                        <span class="icon margin-right-xxs" aria-hidden="true">
                            <span class="docon docon-edit-copy"></span>
                        </span>
                        <span>复制</span>
                        <div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent"
                            aria-hidden="true">
                            <span class="icon font-size-lg">
                                <span class="docon docon-check-mark"></span>
                            </span>
                        </div>
                    </button>
                </div>
                <pre class="has-inner-focus"><code class="lang-cpp" data-author-content="#define SIZE 10 // C-style
                    constexpr int size = 10; // modern C++
                    "><span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE 10 <span class="hljs-comment">// C-style</span></span>
                    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">10</span>; <span class="hljs-comment">// modern C++</span>
                    </span></code></pre>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#uniform-initialization" aria-label="节标题：统一初始化"></a>
                    <h2 id="uniform-initialization" class="heading-anchor">统一初始化</h2>
                </div>
                <p>在现代 C++ 中，可以使用任何类型的括号初始化。 在初始化数组、矢量或其他容器时，这种初始化形式会非常方便。 在下面的示例中，使用三个 <code>S</code> 实例初始化
                    <code>v2</code>。
                    <code>v3</code> 将使用三个 <code>S</code> 实例进行初始化，这些实例使用括号初始化自身。 编译器基于 <code>v3</code> 声明的类型推断每个元素的类型。
                </p>
                <div class="codeHeader" id="code-try-7" data-bi-name="code-header"><span class="language">C++</span>
                    <button type="button" class="action position-relative display-none-print" data-bi-name="copy">
                        <span class="icon margin-right-xxs" aria-hidden="true">
                            <span class="docon docon-edit-copy"></span>
                        </span>
                        <span>复制</span>
                        <div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent"
                            aria-hidden="true">
                            <span class="icon font-size-lg">
                                <span class="docon docon-check-mark"></span>
                            </span>
                        </div>
                    </button>
                </div>
                <pre class="has-inner-focus"><code class="lang-cpp" data-author-content="#include <vector>
                    
                    struct S
                    {
                        std::string name;
                        float num;
                        S(std::string s, float f) : name(s), num(f) {}
                    };
                    
                    int main()
                    {
                        // C-style initialization
                        std::vector<S> v;
                        S s1(&quot;Norah&quot;, 2.7);
                        S s2(&quot;Frank&quot;, 3.5);
                        S s3(&quot;Jeri&quot;, 85.9);
                    
                        v.push_back(s1);
                        v.push_back(s2);
                        v.push_back(s3);
                    
                        // Modern C++:
                        std::vector<S> v2 {s1, s2, s3};
                    
                        // or...
                        std::vector<S> v3{ {&quot;Norah&quot;, 2.7}, {&quot;Frank&quot;, 3.5}, {&quot;Jeri&quot;, 85.9} };
                    
                    }
                    "><span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
                    
                    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span>
                    {</span>
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;
                        <span class="hljs-keyword">float</span> num;
                        S(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">float</span> f) : name(s), num(f) {}
                    };
                    
                    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
                    </span>{
                        <span class="hljs-comment">// C-style initialization</span>
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;S&gt; v;
                        <span class="hljs-function">S <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">"Norah"</span>, <span class="hljs-number">2.7</span>)</span></span>;
                        <span class="hljs-function">S <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">"Frank"</span>, <span class="hljs-number">3.5</span>)</span></span>;
                        <span class="hljs-function">S <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">"Jeri"</span>, <span class="hljs-number">85.9</span>)</span></span>;
                    
                        v.push_back(s1);
                        v.push_back(s2);
                        v.push_back(s3);
                    
                        <span class="hljs-comment">// Modern C++:</span>
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;S&gt; v2 {s1, s2, s3};
                    
                        <span class="hljs-comment">// or...</span>
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;S&gt; v3{ {<span class="hljs-string">"Norah"</span>, <span class="hljs-number">2.7</span>}, {<span class="hljs-string">"Frank"</span>, <span class="hljs-number">3.5</span>}, {<span class="hljs-string">"Jeri"</span>, <span class="hljs-number">85.9</span>} };
                    
                    }
                    </span></code></pre>
                <p>若要了解详细信息，请参阅<a
                        href="https://learn.microsoft.com/zh-cn/cpp/cpp/initializing-classes-and-structs-without-constructors-cpp?view=msvc-170"
                        data-linktype="relative-path">括号初始化</a>。</p>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#move-semantics" aria-label="节标题：移动语义"></a>
                    <h2 id="move-semantics" class="heading-anchor">移动语义</h2>
                </div>
                <p>现代 C++ 提供了移动语义，此功能可以避免进行不必要的内存复制。 在此语言的早期版本中，在某些情况下无法避免复制。 移动操作会将资源的所有权从一个对象转移到下一个对象，而不必再进行复制。
                    一些类拥有堆内存、文件句柄等资源。
                    实现资源所属的类时，可以定义此类的移动构造函数和移动赋值运算符。 在解析重载期间，如果不需要进行复制，编译器会选择这些特殊成员。 如果定义了移动构造函数，则标准库容器类型会在对象中调用此函数。
                    有关详细信息，请参阅<a
                        href="https://learn.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170"
                        data-linktype="relative-path">移动构造函数和移动赋值运算符 (C++)</a>。</p>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#lambda-expressions" aria-label="节标题：Lambda 表达式"></a>
                    <h2 id="lambda-expressions" class="heading-anchor">Lambda 表达式</h2>
                </div>
                <p>在 C 样式编程中，可以通过使用函数指针将函数传递到另一个函数。 函数指针不便于维护和理解。 它们引用的函数可能是在源代码的其他位置中定义的，而不是从调用它的位置定义的。 此外，它们不是类型安全的。
                    现代 C++
                    提供了函数对象和重写 <a
                        href="https://learn.microsoft.com/zh-cn/cpp/cpp/function-call-operator-parens?view=msvc-170"
                        data-linktype="relative-path"><code>operator()</code></a> 运算符的类，可以像调用函数一样调用它们。 创建函数对象的最简便方法是使用内联
                    <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170"
                        data-linktype="relative-path">lambda 表达式</a>。 下面的示例演示如何使用 lambda 表达式传递函数对象，然后由
                    <code>find_if</code>
                    函数在矢量的每个元素中调用此函数对象：
                </p>
                <div class="codeHeader" id="code-try-8" data-bi-name="code-header"><span class="language">C++</span>
                    <button type="button" class="action position-relative display-none-print" data-bi-name="copy">
                        <span class="icon margin-right-xxs" aria-hidden="true">
                            <span class="docon docon-edit-copy"></span>
                        </span>
                        <span>复制</span>
                        <div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent"
                            aria-hidden="true">
                            <span class="icon font-size-lg">
                                <span class="docon docon-check-mark"></span>
                            </span>
                        </div>
                    </button>
                </div>
                <pre class="has-inner-focus"><code class="lang-cpp" data-author-content="    std::vector<int> v {1,2,3,4,5};
                        int x = 2;
                        int y = 4;
                        auto result = find_if(begin(v), end(v), [=](int i) { return i > x &amp;&amp; i < y; });
                    "><span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
                        <span class="hljs-keyword">int</span> x = <span class="hljs-number">2</span>;
                        <span class="hljs-keyword">int</span> y = <span class="hljs-number">4</span>;
                        <span class="hljs-keyword">auto</span> result = find_if(begin(v), end(v), [=](<span class="hljs-keyword">int</span> i) { <span class="hljs-keyword">return</span> i &gt; x &amp;&amp; i &lt; y; });
                    </span></code></pre>
                <p>可以将 lambda 表达式 <code>[=](int i) { return i &gt; x &amp;&amp; i &lt; y; }</code> 理解为“采用类型
                    <strong><code>int</code></strong> 的单个参数并返回一个布尔值来表示此参数是否大于 <code>x</code> 并且小于 <code>y</code>
                    的函数”。请注意，可在
                    lambda
                    中使用来自周围上下文的 <code>x</code> 和 <code>y</code> 变量。 <code>[=]</code> 会指定通过值捕获这些变量；换言之，对于这些值，lambda
                    表达式具有自己的值副本。
                </p>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#exceptions" aria-label="节标题：异常"></a>
                    <h2 id="exceptions" class="heading-anchor">异常</h2>
                </div>
                <p>与错误代码相比，新式 C++ 更注重异常，将其作为报告和处理错误条件的最佳方法。 有关详细信息，请参阅<a
                        href="https://learn.microsoft.com/zh-cn/cpp/cpp/errors-and-exception-handling-modern-cpp?view=msvc-170"
                        data-linktype="relative-path">现代 C++ 处理异常和错误的最佳做法</a>。</p>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#stdatomic" aria-label="节标题：std::atomic"></a>
                    <h2 id="stdatomic" class="heading-anchor"><code>std::atomic</code></h2>
                </div>
                <p>对线程间通信机制使用 C++ 标准库 <a
                        href="https://learn.microsoft.com/zh-cn/cpp/standard-library/atomic-structure?view=msvc-170"
                        data-linktype="relative-path"><code>std::atomic</code></a> 结构和相关类型。</p>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#stdvariant-c17" aria-label="节标题：std::variant (C++17)"></a>
                    <h2 id="stdvariant-c17" class="heading-anchor"><code>std::variant</code> (C++17)</h2>
                </div>
                <p>C 样式编程通常通过并集使不同类型的成员可以占用同一个内存位置，从而节省内存。 但是，并集不是类型安全的，并且容易导致编程错误。 C++17 引入了更加安全可靠的 <a
                        href="https://learn.microsoft.com/zh-cn/cpp/standard-library/variant-class?view=msvc-170"
                        data-linktype="relative-path"><code>std::variant</code></a> 类，来作为并集的替代项。 可以使用 <a
                        href="https://learn.microsoft.com/zh-cn/cpp/standard-library/variant-functions?view=msvc-170#visit"
                        data-linktype="relative-path"><code>std::visit</code></a> 函数以类型安全的方式访问 <code>variant</code>
                    类型的成员。</p>
                <div class="heading-wrapper" data-heading-level="h2"><a class="anchor-link docon docon-link"
                        href="#see-also" aria-label="节标题：请参阅"></a>
                    <h2 id="see-also" class="heading-anchor">请参阅</h2>
                </div>
                <p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-language-reference?view=msvc-170"
                        data-linktype="relative-path">C++ 语言参考</a><br>
                    <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170"
                        data-linktype="relative-path">Lambda 表达式</a><br>
                    <a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/cpp-standard-library-reference?view=msvc-170"
                        data-linktype="relative-path">C++ 标准库</a><br>
                    <a href="https://learn.microsoft.com/zh-cn/cpp/overview/visual-cpp-language-conformance?view=msvc-170"
                        data-linktype="relative-path">Microsoft C/C++ 语言一致性</a>
                </p><br>
                <ul>
                    <li>该文章只为学习html时转载使用</li>
                    <br>
                    <li><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-170"
                            style="color:rgb(237, 5, 245)">原文章链接</a></li>
                </ul><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
            </div>
        </div>
        <div>&nbsp;</div><br>
        <div class="layui-col-md1">&nbsp;</div>
        <script src="./layui/layui.js"></script>
        <script>
            // Usage
            layui.use(function () {
                var layer = layui.layer;
                // Welcome
                layer.msg('Welcome to article:欢迎回到 C++ - 现代 C++', { icon: 6 });
            });
        </script>
        <script src="asserts/js/prism.js"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                Prism.highlightAll();
            });
        </script>
        </body>

</html>